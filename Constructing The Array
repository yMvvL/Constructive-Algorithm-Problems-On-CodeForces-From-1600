https://codeforces.com/contest/1353/problem/D
YYSY这个题一开始没有想到一些比较取巧（无贬义）的做法，于是我选择直接STL大模拟
利用multiset<pair<int, int>>来存储每条线段的长度和左右端点，并自定义一个排序函数使得元素按照这样的顺序进行排序：
1.如果线段长度不同，那么就将长度更长的放在multiset的前面
2.如果线段长度相同，那么就将左端点更小的放在前面（长度相同的话肯定左端点更小的对应的是左边的线段）
这样的话正常模拟一遍就可以了
注：模拟的时候要注意ans数组的索引和线段的端点
AC代码：
void solve() {
    int n;
    std::cin >> n;

    std::multiset<std::pair<int, int>, std::function<bool(std::pair<int, int>, std::pair<int, int>)>> st([] (std::pair<int, int> p1, std::pair<int, int> p2){
        int d1 = p1.second - p1.first;
        int d2 = p2.second - p2.first;
        if (d1 != d2) {
            return d1 > d2;
        } else {
            return p1.first < p2.first;
        }
    });

    std::vector<int> ans(n);
    st.insert({1, n});
    int cnt = 1;
    while (!st.empty()) {
        auto[l, r] = *st.begin();
        st.erase(st.begin());

        int x;
        if ((r - l + 1) % 2 == 1) {
            x = (l + r) / 2 - 1;
        } else {
            x = (l + r - 1) / 2 - 1;
        }

        ans[x] = cnt;
        if (cnt == n) {
            break;
        }
        cnt++;
        int mid = x + 1;
        if (l <= mid - 1) {
            st.insert({l, mid - 1});;
        }
        if (mid + 1 <= r) {
            st.insert({mid + 1, r});
        }
    }

    for (auto x : ans) {
        std::cout << x << " ";
    }
    std::cout << "\n";
}
