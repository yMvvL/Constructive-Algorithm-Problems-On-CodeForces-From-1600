<https://codeforces.com/contest/1396/problem/A>  
这个题思考起来还是很舒服的，一开始想的是找所有数的最大公约数最小公倍数之类的但是似乎不是这样的    
受到之前那个一堆 $n/2$ 的那个题的启发，我寻思的是先给数组对半开，但是发现长度还是不好控制    
之后我又想到了长度为 $2$ 的情况，但是太短了，肯定不能对每个长度为 $2$ 的数组都这样处理，这时候我手算了一个数据得到了很大启发：    
```
6    
1 3 2 4 5 6
```    
我注意到如果按 $4,2$ 来分的话会导致左边那个 $3$ 怎么也构造不出 $4$ 的倍数，此时脑子里面突然有了个想法：  
## 既然要让它能整除长度（最终结果要是0），那也就是说要控制取模后的余数为0，这样的话想办法能让它的余数能不断加一就可以了  
那么怎样才能不断加一就成了下一个问题，在上一步思考完之后就不难想到了， $1$！  
没错，我们一开始选整个数组长度，这样的话我们分成两部分， $1到n-1$ 为第一部分， $n$是第二部分，这样的话左边总是可以构造出 $n-1$ 的倍数，也就是变成 $a_i + n * ((n - a_i$ % $(n - 1))$ % $(n - 1))$    
右半部分由于长度为 $1$ 所以直接输出相反数即可，这样恰好三次完成  
注意特判 $n=1$ 的情况  
AC代码：  
```C++
void solve() {
    long long n;
    std::cin >> n;

    std::vector<long long> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }

    if (n == 1) {
        std::cout << "1 1\n" << -a.back() << "\n";
        std::cout << "1 1\n" << -a.back() << "\n";
        std::cout << "1 1\n" << a.back() << "\n";
        return ;
    }

    long long m = n - 1;
    std::cout << 1 << " " << n << "\n";
    for (int i = 0; i < n; i++) {
        long long t = a[i];
        a[i] += n * ((m - a[i] % m) % m);
        std::cout << a[i] - t << " ";
    }
    std::cout << "\n";

    std::cout << 1 << " " << m << "\n";
    for (int i = 0; i < m; i++) {
        std::cout << -a[i] << " ";
    }
    std::cout << "\n";

    std::cout << n << " " << n << "\n";
    std::cout << -a.back() << "\n";
}
```
